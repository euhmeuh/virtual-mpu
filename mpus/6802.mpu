#lang s-exp "../emulator/mpu-lang.rkt"
(mpu "6802"
  (registers (a b sr [ix 16] [sp 16] [pc 16]))
  (status sr (carry zero sign overflow interrupt half))
  (interrupts [irq #xFFF8] [soft #xFFFA] [nmi #xFFFC] [restart #xFFFE])
  (operations

    ;; branches
    (bcc "Branch if carry clear" (rel) (branch pc (carry?) rel))
    (bcs "Branch if carry set" (rel) (branch pc (not (carry?)) rel))

    (bvc "Branch if overflow clear" (rel) (branch pc (overflow?) rel))
    (bvs "Branch if overflow set" (rel) (branch pc (not (overflow?)) rel))

    (beq "Branch if =0" (rel) (branch pc (zero?) rel))
    (bne "Branch if !=0" (rel) (branch pc (not (zero?)) rel))

    (bge "Branch if >=0" (rel) (branch pc (not (xor (sign?) (overflow?))) rel))
    (blt "Branch if <0" (rel) (branch pc (xor (sign?) (overflow?)) rel))

    (ble "Branch if <=0" (rel) (branch pc (or (zero?) (xor (sign?) (overflow?))) rel))
    (bgt "Branch if >0" (rel) (branch pc (not (or (zero?) (xor (sign?) (overflow?)))) rel))

    (bhi "Branch if higher" (rel) (branch pc (not (or (zero?) (carry?))) rel))
    (bls "Branch if lesser" (rel) (branch pc (or (zero?) (carry?)) rel))

    (bmi "Branch if minus" (rel) (branch pc (sign?) rel))
    (bpl "Branch if plus" (rel) (branch pc (not (sign?)) rel))

    (bra "Branch always to ~a" (rel) (branch pc #t rel))
    (bsr "Branch always to subroutine ~a" (rel) (push! sp (low pc))
                                                (push! sp (high pc))
                                                (branch pc #t rel))

    ;; moves
    (lda "Load ~a <- ~a"  (dest val) (val . -> . dest))
    (lds "Load SP <- ~a"  (val)      (val . -> . sp))
    (ldx "Load IX <- ~a"  (val)      (val . -> . ix))
    (sta "Store ~a -> ~a" (reg dest) (reg . -> . (ref dest)))
    (sts "Store SP -> ~a" (dest)     (sp . -> . (ref dest)))
    (stx "Store IX -> ~a" (dest)     (ix . -> . (ref dest)))
    (tab "A -> B"       () (a . -> . b))
    (tba "B -> A"       () (b . -> . a))
    (tap "A -> SR"      () (a . -> . sr))
    (tpa "SR -> A"      () (sr . -> . a))
    (tsx "SP + 1 -> IX" () ((+ sp 1) . -> . ix))
    (txs "IX - 1 -> SP" () ((- ix 1) . -> . sp))

    ;; control
    (dex "IX - 1 -> IX" () ((- ix 1) . -> . ix))
    (inx "IX + 1 -> IX" () ((+ ix 1) . -> . ix))
    (jmp "Jump to ~a" (abs) (abs . -> . pc))
    (jsr "Jump to subroutine at ~a" () (void))
    (rts "Return from subroutine" () (void))
    (rti "Return from interrupt" () (void))
    (swi "Software interrupt" () (void))

    ;; stack
    (des "SP - 1 -> SP" () ((- sp 1) . -> . sp))
    (ins "SP + 1 -> SP" () ((+ sp 1) . -> . sp))
    (psh "~a -> [SP]" (src) (push! sp src))
    (pul "[SP] -> ~a" (dest) (pull! sp dest))

    ;; maths
    (aba "A + B -> A" () ((+ a b) . -> . a))
    (adc "~a + ~a (with carry)" () (void))
    (add "~a + ~a (without carry)" () (void))
    (sba "A - B -> A" () (void))
    (sbc "~a - ~a (with carry)" () (void))
    (sub "~a - ~a (without carry)" () (void))
    (and "~a AND ~a" () (void))
    (ora "~a OR ~a" () (void))
    (eor "~a XOR ~a" () (void))
    (asl "~a shifted left" () (void))
    (asr "~a shifted right" () (void))
    (lsr "~a logically shifted right" () (void))
    (dec "~a - 1" () (void))
    (inc "~a + 1" () (void))
    (rol "Rotate left through carry" () (void))
    (ror "Rotate right through carry" () (void))
    (com "Complement ~a -> ~a" () (void))
    (neg "Negate ~a -> ~a" () (void))
    (daa "Decimal adjust A" () (void))

    ;; status
    (bit "A AND B -> SR" () (void))
    (cba "A - B -> SR" () (void))
    (cmp "~a - ~a -> SR" () (void))
    (cpx "IX - ~a -> SR" () (void))
    (tst "~a - 0 -> SR" () (void))

    ;; clear
    (clr "Clear ~a" () (void))
    (clc "Clear carry" () (void))
    (cli "Clear interrupt" () (void))
    (clv "Clear overflow" () (void))

    ;; set
    (sec "Set carry" () (void))
    (sei "Set interrupt" () (void))
    (sev "Set overflow" () (void))

    ;; noop
    (nop "Do nothing" () (void))
    (wai "Wait for interrupt" () (void))
    ))
