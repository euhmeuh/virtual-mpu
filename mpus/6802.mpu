#lang s-exp "../emulator/mpu-lang.rkt"
(mpu "6802"
  (registers (a b sr [ix 16] [sp 16] [pc 16]))
  (status sr (carry zero sign overflow interrupt half))
  (interrupts [irq #xFFF8] [soft #xFFFA] [nmi #xFFFC] [restart #xFFFE])
  (operations

    ;; branches
    (bcc "Branch if carry clear" (rel) (branch pc (carry?) rel))
    (bcs "Branch if carry set" (rel) (branch pc (not (carry?)) rel))

    (bvc "Branch if overflow clear" (rel) (branch pc (overflow?) rel))
    (bvs "Branch if overflow set" (rel) (branch pc (not (overflow?)) rel))

    (beq "Branch if =0" (rel) (branch pc (zero?) rel))
    (bne "Branch if !=0" (rel) (branch pc (not (zero?)) rel))

    (bge "Branch if >=0" (rel) (branch pc (not (xor (sign?) (overflow?))) rel))
    (blt "Branch if <0" (rel) (branch pc (xor (sign?) (overflow?)) rel))

    (ble "Branch if <=0" (rel) (branch pc (or (zero?) (xor (sign?) (overflow?))) rel))
    (bgt "Branch if >0" (rel) (branch pc (not (or (zero?) (xor (sign?) (overflow?)))) rel))

    (bhi "Branch if higher" (rel) (branch pc (not (or (zero?) (carry?))) rel))
    (bls "Branch if lesser" (rel) (branch pc (or (zero?) (carry?)) rel))

    (bmi "Branch if minus" (rel) (branch pc (sign?) rel))
    (bpl "Branch if plus" (rel) (branch pc (not (sign?)) rel))

    (bra "Branch always to ~a" (rel) (branch pc #t rel))
    (bsr "Branch always to subroutine ~a" (rel) (push! sp (low pc))
                                                (push! sp (high pc))
                                                (branch pc #t rel))

    ;; moves
    (ldaa "Load A <- ~a" (val) (val . -> . a))
    (ldab "Load B <- ~a" (val) (val . -> . b))
    (lds "Load SP <- ~a" (val) (val . -> . sp))
    (ldx "Load IX <- ~a" (val) (val . -> . ix))
    (staa "Store A -> ~a" (dest) (a . -> . dest))
    (stab "Store B -> ~a" (dest) (b . -> . dest))
    (sts "Store SP -> ~a" (dest) (sp . -> . dest))
    (stx "Store IX -> ~a" (dest) (ix . -> . dest))
    (tab "A -> B" () (a . -> . b))
    (tba "B -> A" () (b . -> . a))
    (tap "A -> SR" () (a . -> . sr))
    (tpa "SR -> A" () (sr . -> . a))
    (tsx "SP + 1 -> IX" () ((+ sp 1) . -> . ix))
    (txs "IX - 1 -> SP" () ((- ix 1) . -> . sp))

    ;; control
    (dex "IX - 1 -> IX" () ((- ix 1) . -> . ix))
    (inx "IX + 1 -> IX" () ((+ ix 1) . -> . ix))
    (jmp "Jump to ~a" (abs) (abs . -> . pc))
    (jsr "Jump to subroutine at ~a" () (void))
    (rts "Return from subroutine" () (void))
    (rti "Return from interrupt" () (void))
    (swi "Software interrupt" () (void))

    ;; stack
    (des "SP - 1 -> SP" () ((- sp 1) . -> . sp))
    (ins "SP + 1 -> SP" () ((+ sp 1) . -> . sp))
    (psh "~a -> [SP]" (src) (push! sp src))
    (pul "[SP] -> ~a" (dest) (pull! sp dest))

    ;; maths
    (aba "A + B -> A" () ((+ a b) . -> . a))
    (sba "A - B -> A" () ((- a b) . -> . a))
    (adca "A + ~a + carry -> A" (val) ((+ a val (carry)) . -> . a))
    (adcb "B + ~a + carry -> B" (val) ((+ b val (carry)) . -> . b))
    (sbca "A - ~a - carry -> A" (val) ((- a val (carry)) . -> . a))
    (sbcb "B - ~a - carry -> B" (val) ((- b val (carry)) . -> . b))
    (adda "A + ~a -> A (no carry)" (val) ((+ a val) . -> . a))
    (addb "B + ~a -> B (no carry)" (val) ((+ b val) . -> . b))
    (suba "A - ~a -> A (no carry)" (val) ((- a val) . -> . a))
    (subb "B - ~a -> B (no carry)" (val) ((- b val) . -> . b))
    (anda "A AND ~a" (val) ((bitwise-and a val) . -> . a))
    (andb "B AND ~a" (val) ((bitwise-and b val) . -> . b))
    (oraa "A OR ~a"  (val) ((bitwise-ior a val) . -> . a))
    (orab "B OR ~a"  (val) ((bitwise-ior b val) . -> . b))
    (eora "A XOR ~a" (val) ((bitwise-xor a val) . -> . a))
    (eorb "B XOR ~a" (val) ((bitwise-xor b val) . -> . b))
    (asl "~a shifted left" (val) ((arithmetic-shift (ref val) 1) . -> . val))
    (asla "A shifted left" () ((arithmetic-shift a 1) . -> . a))
    (aslb "B shifted left" () ((arithmetic-shift b 1) . -> . b))
    (asr "~a shifted right" (val) ((arithmetic-shift-right (ref val)) . -> . val) (sign #f))
    (asra "A shifted right" () ((arithmetic-shift-right a) . -> . a) (sign #f))
    (asrb "B shifted right" () ((arithmetic-shift-right b) . -> . b) (sign #f))
    (lsr "~a logically shifted right" (val) ((arithmetic-shift (ref val) -1) . -> . val))
    (lsra "A logically shifted right" () ((arithmetic-shift a -1) . -> . a))
    (lsrb "B logically shifted right" () ((arithmetic-shift b -1) . -> . b))
    (dec "~a - 1" (val) ((- (ref val) 1) . -> . val))
    (deca "A - 1 -> A" () ((- a 1) . -> . a))
    (decb "B - 1 -> B" () ((- b 1) . -> . b))
    (inc "~a + 1" (val) ((+ (ref val) 1) . -> . val))
    (inca "A + 1" () ((+ a 1) . -> . a))
    (incb "B + 1" () ((+ b 1) . -> . b))
    (rol "Rotate ~a left through carry" () (void))
    (rola "Rotate A left through carry" () (void))
    (rolb "Rotate B left through carry" () (void))
    (ror "Rotate ~a right through carry" () (void))
    (rora "Rotate A right through carry" () (void))
    (rorb "Rotate B right through carry" () (void))
    (com "Complement ~a" () (void))
    (coma "Complement A" () (void))
    (comb "Complement B" () (void))
    (neg "Negate ~a" () (void))
    (nega "Negate A" () (void))
    (negb "Negate B" () (void))
    (daa "Decimal adjust A" () (void))

    ;; status
    (bita "A AND ~a -> SR" (val) (void))
    (bitb "B AND ~a -> SR" (val) (void))
    (cba "A - B -> SR" () (void))
    (cmpa "A - ~a -> SR" (val) (void))
    (cmpb "B - ~a -> SR" (val) (void))
    (cpx "IX - ~a -> SR" (val) (void))
    (tst "~a - 0 -> SR" (val) (void))
    (tsta "A - 0 -> SR" () (void))
    (tstb "B - 0 -> SR" () (void))

    ;; clear
    (clr "Clear ~a" (dest) (0 . -> . dest))
    (clra "Clear A" () (0 . -> . a))
    (clrb "Clear B" () (0 . -> . b))
    (clc "Clear carry" () (carry #f))
    (cli "Clear interrupt" () (interrupt #f))
    (clv "Clear overflow" () (overflow #f))

    ;; set
    (sec "Set carry" () (carry #t))
    (sei "Set interrupt" () (interrupt #t))
    (sev "Set overflow" () (overflow #t))

    ;; noop
    (nop "Do nothing" () (void))
    (wai "Wait for interrupt" () (void))
    ))
