#lang s-exp "../emulator/mpu-lang.rkt"
(mpu "6802"
  (registers (a b sr [ix 16] [sp 16] [pc 16]))
  (status sr (carry zero sign overflow interrupt half))
  (interrupts [irq #xFFF8] [soft #xFFFA] [nmi #xFFFC] [restart #xFFFE])
  (operations

    ;; branches
    (bcc "Branch if carry clear" (rel) (branch pc (carry?) rel))
    (bcs "Branch if carry set" (rel) (branch pc (not (carry?)) rel))

    (bvc "Branch if overflow clear" (rel) (branch pc (overflow?) rel))
    (bvs "Branch if overflow set" (rel) (branch pc (not (overflow?)) rel))

    (beq "Branch if =0" (rel) (branch pc (zero?) rel))
    (bne "Branch if !=0" (rel) (branch pc (not (zero?)) rel))

    (bge "Branch if >=0" (rel) (branch pc (not (xor (sign?) (overflow?))) rel))
    (blt "Branch if <0" (rel) (branch pc (xor (sign?) (overflow?)) rel))

    (ble "Branch if <=0" (rel) (branch pc (or (zero?) (xor (sign?) (overflow?))) rel))
    (bgt "Branch if >0" (rel) (branch pc (not (or (zero?) (xor (sign?) (overflow?)))) rel))

    (bhi "Branch if higher" (rel) (branch pc (not (or (zero?) (carry?))) rel))
    (bls "Branch if lesser" (rel) (branch pc (or (zero?) (carry?)) rel))

    (bmi "Branch if minus" (rel) (branch pc (sign?) rel))
    (bpl "Branch if plus" (rel) (branch pc (not (sign?)) rel))

    (bra "Branch always to ~a" (rel) (branch pc #t rel))
    (bsr "Branch always to subroutine ~a" (rel) (push! sp (low pc))
                                                (push! sp (high pc))
                                                (branch pc #t rel))

    ;; moves
    (lda "Load ~a <- ~a"  (dest val) (val . -> . dest))
    (lds "Load SP <- ~a"  (val)      (val . -> . sp))
    (ldx "Load IX <- ~a"  (val)      (val . -> . ix))
    (sta "Store ~a -> ~a" (reg dest) (reg . -> . dest))
    (sts "Store SP -> ~a" (dest)     (sp . -> . dest))
    (stx "Store IX -> ~a" (dest)     (ix . -> . dest))
    (tab "A -> B"       () (a . -> . b))
    (tba "B -> A"       () (b . -> . a))
    (tap "A -> SR"      () (a . -> . sr))
    (tpa "SR -> A"      () (sr . -> . a))
    (tsx "SP + 1 -> IX" () ((+ sp 1) . -> . ix))
    (txs "IX - 1 -> SP" () ((- ix 1) . -> . sp))

    ;; control
    (dex "IX - 1 -> IX" () ((- ix 1) . -> . ix))
    (inx "IX + 1 -> IX" () ((+ ix 1) . -> . ix))
    (jmp "Jump to ~a" (abs) (abs . -> . pc))
    (jsr "Jump to subroutine at ~a" () (void))
    (rts "Return from subroutine" () (void))
    (rti "Return from interrupt" () (void))
    (swi "Software interrupt" () (void))

    ;; stack
    (des "SP - 1 -> SP" () ((- sp 1) . -> . sp))
    (ins "SP + 1 -> SP" () ((+ sp 1) . -> . sp))
    (psh "~a -> [SP]" (src) (push! sp src))
    (pul "[SP] -> ~a" (dest) (pull! sp dest))

    ;; maths
    (aba "A + B -> A" () ((+ a b) . -> . a))
    (sba "A - B -> A" () ((- a b) . -> . a))
    (adc "~a + ~a (with carry)" (reg val) ((+ reg val (carry)) . -> . reg))
    (sbc "~a - ~a (with carry)" (reg val) ((- reg val (carry)) . -> . reg))
    (add "~a + ~a (without carry)" (reg val) ((+ reg val) . -> . reg))
    (sub "~a - ~a (without carry)" (reg val) ((- reg val) . -> . reg))
    (and "~a AND ~a" (reg val) ((bitwise-and reg val) . -> . reg))
    (ora "~a OR ~a"  (reg val) ((bitwise-ior reg val) . -> . reg))
    (eor "~a XOR ~a" (reg val) ((bitwise-xor reg val) . -> . reg))
    (asl "~a shifted left" (val) ((arithmetic-shift val 1) . -> . val))
    (asr "~a shifted right" (val) ((arithmetic-shift-right val) . -> . val)
                                  (sign 0))
    (lsr "~a logically shifted right" (val) ((arithmetic-shift val -1) . -> . val))
    (dec "~a - 1" (val) ((- val 1) . -> . val))
    (inc "~a + 1" (val) ((+ val 1) . -> . val))
    (rol "Rotate left through carry" () (void))
    (ror "Rotate right through carry" () (void))
    (com "Complement ~a -> ~a" () (void))
    (neg "Negate ~a -> ~a" () (void))
    (daa "Decimal adjust A" () (void))

    ;; status
    (bit "A AND B -> SR" () (void))
    (cba "A - B -> SR" () (void))
    (cmp "~a - ~a -> SR" () (void))
    (cpx "IX - ~a -> SR" () (void))
    (tst "~a - 0 -> SR" () (void))

    ;; clear
    (clr "Clear ~a" () (void))
    (clc "Clear carry" () (void))
    (cli "Clear interrupt" () (void))
    (clv "Clear overflow" () (void))

    ;; set
    (sec "Set carry" () (void))
    (sei "Set interrupt" () (void))
    (sev "Set overflow" () (void))

    ;; noop
    (nop "Do nothing" () (void))
    (wai "Wait for interrupt" () (void))
    ))
