#lang racket/base

(require
  racket/function
  racket/bool
  racket/stxparam
  (for-syntax
    racket/base
    racket/list
    racket/syntax
    syntax/parse
    syntax/stx))

(struct mpu-info (name registers status interrupts operations) #:transparent)
(struct status-info (register bits) #:transparent)
(struct reg-info (name size getter setter) #:transparent)
(struct op-info (name desc proc) #:transparent)

(begin-for-syntax
  (define-syntax-class register
    (pattern (name size))
    (pattern name #:with size #'8)))

(define-syntax-parameter ->
  (lambda (stx)
    (raise-syntax-error '-> "can only be used inside of mpu definition" stx)))

(define-syntax-parameter branch
  (lambda (stx)
    (raise-syntax-error 'branch "can only be used inside of mpu definition" stx)))

(define-syntax-parameter push!
  (lambda (stx)
    (raise-syntax-error 'push! "can only be used inside of mpu definition" stx)))

(define-syntax-parameter pull!
  (lambda (stx)
    (raise-syntax-error 'pull! "can only be used inside of mpu definition" stx)))

(define-syntax (mpu stx)
  (syntax-parse stx
    #:datum-literals (registers status interrupts)
    [(_ name (registers (r:register ...))
             (status status-reg (bit ...))
             (interrupts [int-name int-value] ...)
             operations)
     #:with bits #'(bit ...)
     #:with ((bit? pos) ...) (stx-map (lambda (id)
                                        #`(#,(format-id id "~a?" id)
                                           #,(expt 2 (index-of (syntax->list #'bits) id))))
                                      #'bits)
     #'(let* ([r.name 0] ...
              [bit? (thunk (= 0 (bitwise-and status-reg pos)))] ...
              [registers (make-hasheq `([r.name . ,(reg-info 'r.name
                                                  r.size
                                                  (thunk r.name)
                                                  (lambda (v) (set! r.name v)))] ...))])
         (mpu-info
           name
           registers
           (status-info 'status-reg 'bits)
           (make-hasheq '([int-name . int-value] ...))
           (syntax-parameterize
             ([-> (lambda (stx)
                    (syntax-case stx () [(_ src dest) (if (member (syntax->datum #'dest)
                                                                  (syntax->datum #'(r.name ...)))
                                                          #'(set! dest src)
                                                          #'(memory-set! dest src))]))]
              [branch (syntax-rules () [(_ pc condition rel)
                                        (begin (when condition
                                               ((+ pc rel) . -> . pc)))])]
              [push! (syntax-rules () [(_ reg value)
                                       (begin (value . -> . (ref reg))
                                              ((- reg 1) . -> . reg))])]
              [pull! (syntax-rules () [(_ reg dest)
                                       (begin ((+ reg 1) . -> . reg)
                                              ((ref reg) . -> . dest))])])
             operations)))]))

(define-syntax (operations stx)
  (syntax-parse stx
    [(_ (name desc (arg ...) body ...) ...)
     #'(make-hasheq `([name . ,(op-info 'name
                                        'desc
                                        (lambda (arg ...) body ...))] ...))]))

(define ((reverse-args dual-arity-proc) a b)
  (dual-arity-proc b a))

(define (high reg)
  (bitwise-and (arithmetic-shift reg -8) #xFF))

(define (low reg)
  (bitwise-and reg #xFF))

(define (ref reg)
  reg)

(define (mpu-call mpu op . operands)
  (define found-op (hash-ref (mpu-info-operations mpu) op #f))
  (when found-op
    (displayln (apply format (op-info-desc found-op) operands))
    (apply (op-info-proc found-op) operands)))

(define (mpu-get-reg mpu reg)
  (define found-reg (hash-ref (mpu-info-registers mpu) reg #f))
  (and found-reg ((reg-info-getter found-reg))))

(define (mpu-set-reg! mpu reg value)
  (define found-reg (hash-ref (mpu-info-registers mpu) reg #f))
  (and found-reg ((reg-info-setter found-reg) value)))

(define (memory-set! addr value)
  (void))

(define the-mpu
  (mpu "6802"
    (registers (a b sr [ix 16] [sp 16] [pc 16]))
    (status sr (carry zero sign overflow interrupt half))
    (interrupts [irq #xFFF8] [soft #xFFFA] [nmi #xFFFC] [restart #xFFFE])
    (operations

      ;; branches
      (bcc "Branch if carry clear" (rel) (branch pc (carry?) rel))
      (bcs "Branch if carry set" (rel) (branch pc (not (carry?)) rel))

      (bvc "Branch if overflow clear" (rel) (branch pc (overflow?) rel))
      (bvs "Branch if overflow set" (rel) (branch pc (not (overflow?)) rel))

      (beq "Branch if =0" (rel) (branch pc (zero?) rel))
      (bne "Branch if !=0" (rel) (branch pc (not (zero?)) rel))

      (bge "Branch if >=0" (rel) (branch pc (not (xor (sign?) (overflow?))) rel))
      (blt "Branch if <0" (rel) (branch pc (xor (sign?) (overflow?)) rel))

      (ble "Branch if <=0" (rel) (branch pc (or (zero?) (xor (sign?) (overflow?))) rel))
      (bgt "Branch if >0" (rel) (branch pc (not (or (zero?) (xor (sign?) (overflow?)))) rel))

      (bhi "Branch if higher" (rel) (branch pc (not (or (zero?) (carry?))) rel))
      (bls "Branch if lesser" (rel) (branch pc (or (zero?) (carry?)) rel))

      (bmi "Branch if minus" (rel) (branch pc (sign?) rel))
      (bpl "Branch if plus" (rel) (branch pc (not (sign?)) rel))

      (bra "Branch always to ~a" (rel) (branch pc #t rel))
      (bsr "Branch always to subroutine ~a" (rel) (push! sp (low pc))
                                                  (push! sp (high pc))
                                                  (branch pc #t rel))

      ;; moves
      (lda "Load ~a -> ~a"  (dest val) (val . -> . dest))
      (lds "Load ~a -> SP"  (val)      (val . -> . sp))
      (ldx "Load ~a -> IX"  (val)      (val . -> . ix))
      (sta "Store ~a -> ~a" (reg dest) (reg . -> . (ref dest)))
      (sts "Store SP -> ~a" (dest)     (sp . -> . (ref dest)))
      (stx "Store IX -> ~a" (dest)     (ix . -> . (ref dest)))
      (tab "A -> B"       () (a . -> . b))
      (tba "B -> A"       () (b . -> . a))
      (tap "A -> SR"      () (a . -> . sr))
      (tpa "SR -> A"      () (sr . -> . a))
      (tsx "SP + 1 -> IX" () ((+ sp 1) . -> . ix))
      (txs "IX - 1 -> SP" () ((- ix 1) . -> . sp))

      ;; control
      (dex "IX - 1 -> IX" () ((- ix 1) . -> . ix))
      (inx "IX + 1 -> IX" () ((+ ix 1) . -> . ix))
      (jmp "Jump to ~a" (abs) (abs . -> . pc))
      (jsr "Jump to subroutine at ~a" () (void))
      (rts "Return from subroutine" () (void))
      (rti "Return from interrupt" () (void))
      (swi "Software interrupt" () (void))

      ;; stack
      (des "SP - 1 -> SP" () ((- sp 1) . -> . sp))
      (ins "SP + 1 -> SP" () ((+ sp 1) . -> . sp))
      (psh "~a -> [SP]" (src) (push! sp src))
      (pul "[SP] -> ~a" (dest) (pull! sp dest))

      ;; maths
      (aba "A + B -> A" () ((+ a b) . -> . a))
      (adc "~a + ~a (with carry)" () (void))
      (add "~a + ~a (without carry)" () (void))
      (sba "A - B -> A" () (void))
      (sbc "~a - ~a (with carry)" () (void))
      (sub "~a - ~a (without carry)" () (void))
      (and "~a AND ~a" () (void))
      (ora "~a OR ~a" () (void))
      (eor "~a XOR ~a" () (void))
      (asl "~a shifted left" () (void))
      (asr "~a shifted right" () (void))
      (lsr "~a logically shifted right" () (void))
      (dec "~a - 1" () (void))
      (inc "~a + 1" () (void))
      (rol "Rotate left through carry" () (void))
      (ror "Rotate right through carry" () (void))
      (com "Complement ~a -> ~a" () (void))
      (neg "Negate ~a -> ~a" () (void))
      (daa "Decimal adjust A" () (void))

      ;; status
      (bit "A AND B -> SR" () (void))
      (cba "A - B -> SR" () (void))
      (cmp "~a - ~a -> SR" () (void))
      (cpx "IX - ~a -> SR" () (void))
      (tst "~a - 0 -> SR" () (void))

      ;; clear
      (clr "Clear ~a" () (void))
      (clc "Clear carry" () (void))
      (cli "Clear interrupt" () (void))
      (clv "Clear overflow" () (void))

      ;; set
      (sec "Set carry" () (void))
      (sei "Set interrupt" () (void))
      (sev "Set overflow" () (void))

      ;; noop
      (nop "Do nothing" () (void))
      (wai "Wait for interrupt" () (void))
      )))

(displayln (format "A: ~a" (mpu-get-reg the-mpu 'a)))
(displayln (format "B: ~a" (mpu-get-reg the-mpu 'b)))
(displayln (format "PC: ~a" (mpu-get-reg the-mpu 'pc)))
(mpu-call the-mpu 'lda 'a #x08)
(mpu-call the-mpu 'tab)
(mpu-call the-mpu 'clc)
(mpu-call the-mpu 'aba)
(mpu-call the-mpu 'bra #x4)
(displayln (format "A: ~a" (mpu-get-reg the-mpu 'a)))
(displayln (format "B: ~a" (mpu-get-reg the-mpu 'b)))
(displayln (format "PC: ~a" (mpu-get-reg the-mpu 'pc)))
