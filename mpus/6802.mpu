#lang s-exp "../emulator/mpu-lang.rkt"
(mpu "6802"
  (registers (a b sr [ix 16] [sp 16] [pc 16]))
  (status sr (carry zero sign overflow interrupt half))
  (interrupts interrupt [irq #xFFF8] [soft #xFFFA] [nmi #xFFFC] [restart #xFFFE])
  (operations

    (aliases
      (branch (condition rel) (when condition ((+ pc rel) . -> . pc)))
      (push! (value) (value . ~> . sp)
                     ((- sp 1) . -> . sp))
      (pull! () ((+ sp 1) . -> . sp)
                (ref sp))
      (go-to-interrupt (int) ((high+low (ref int) (ref (+ 1 int))) . -> . pc)))

    ;; branches
    (bcc "Branch if carry clear" (rel) (branch (carry?) rel))
    (bcs "Branch if carry set" (rel) (branch (not (carry?)) rel))

    (bvc "Branch if overflow clear" (rel) (branch (overflow?) rel))
    (bvs "Branch if overflow set" (rel) (branch (not (overflow?)) rel))

    (beq "Branch if =0" (rel) (branch (zero?) rel))
    (bne "Branch if !=0" (rel) (branch (not (zero?)) rel))

    (bge "Branch if >=0" (rel) (branch (not (xor (sign?) (overflow?))) rel))
    (blt "Branch if <0" (rel) (branch (xor (sign?) (overflow?)) rel))

    (ble "Branch if <=0" (rel) (branch (or (zero?) (xor (sign?) (overflow?))) rel))
    (bgt "Branch if >0" (rel) (branch (not (or (zero?) (xor (sign?) (overflow?)))) rel))

    (bhi "Branch if higher" (rel) (branch (not (or (zero?) (carry?))) rel))
    (bls "Branch if lesser" (rel) (branch (or (zero?) (carry?)) rel))

    (bmi "Branch if minus to ~a" (rel) (branch (sign?) rel))
    (bpl "Branch if plus to ~a" (rel) (branch (not (sign?)) rel))

    (bra "Branch always to ~a" (rel) (branch #t rel))
    (bsr "Branch always to subroutine ~a" (rel) (push! (low pc))
                                                (push! (high pc))
                                                (branch #t rel))

    ;; moves
    (ldaa "Load A <- ~a" (val) (val . -> . a))
    (ldab "Load B <- ~a" (val) (val . -> . b))
    (lds "Load SP <- ~a" (val) (val . -> . sp))
    (ldx "Load IX <- ~a" (val) (val . -> . ix))
    (staa "Store A -> ~a" (addr) (a . ~> . addr))
    (stab "Store B -> ~a" (addr) (b . ~> . addr))
    (sts "Store SP -> ~a" (addr) (sp . ~> . addr))
    (stx "Store IX -> ~a" (addr) (ix . ~> . addr))
    (tab "A -> B" () (a . -> . b))
    (tba "B -> A" () (b . -> . a))
    (tap "A -> SR" () (a . -> . sr))
    (tpa "SR -> A" () (sr . -> . a))
    (tsx "SP + 1 -> IX" () ((+ sp 1) . -> . ix))
    (txs "IX - 1 -> SP" () ((- ix 1) . -> . sp))

    ;; control
    (dex "IX - 1 -> IX" () ((- ix 1) . -> . ix))
    (inx "IX + 1 -> IX" () ((+ ix 1) . -> . ix))
    (jmp "Jump to ~a" (abs) (abs . -> . pc))
    (jsr "Jump to subroutine at ~a" (abs) (push! (low pc))
                                          (push! (high pc))
                                          (abs . -> . pc))
    (rts "Return from subroutine" () ((high+low (pull!) (pull!)) . -> . pc))
    (rti "Return from interrupt" () ((pull!) . -> . sr)
                                    ((pull!) . -> . b)
                                    ((pull!) . -> . a)
                                    ((high+low (pull!) (pull!)) . -> . ix)
                                    ((high+low (pull!) (pull!)) . -> . pc))
    (swi "Software interrupt" () (push! (low pc))
                                 (push! (high pc))
                                 (push! (low ix))
                                 (push! (high ix))
                                 (push! a)
                                 (push! b)
                                 (push! sr)
                                 (interrupt #t)
                                 (go-to-interrupt soft))

    ;; stack
    (des "SP - 1 -> SP" () ((- sp 1) . -> . sp))
    (ins "SP + 1 -> SP" () ((+ sp 1) . -> . sp))
    (psha "A -> [SP]" () (push! a))
    (pshb "B -> [SP]" () (push! b))
    (pula "[SP] -> A" () ((pull!) . -> . a))
    (pulb "[SP] -> B" () ((pull!) . -> . b))

    ;; maths
    (aba "A + B -> A" () ((8bit+ a b) . -> . a))
    (sba "A - B -> A" () ((8bit- a b) . -> . a))
    (adca "A + ~a + carry -> A" (val) ((8bit+ a val (carry)) . -> . a))
    (adcb "B + ~a + carry -> B" (val) ((8bit+ b val (carry)) . -> . b))
    (sbca "A - ~a - carry -> A" (val) ((8bit- a val (carry)) . -> . a))
    (sbcb "B - ~a - carry -> B" (val) ((8bit- b val (carry)) . -> . b))
    (adda "A + ~a -> A (no carry)" (val) ((8bit+ a val) . -> . a))
    (addb "B + ~a -> B (no carry)" (val) ((8bit+ b val) . -> . b))
    (suba "A - ~a -> A (no carry)" (val) ((8bit- a val) . -> . a))
    (subb "B - ~a -> B (no carry)" (val) ((8bit- b val) . -> . b))

    (anda "A AND ~a -> A" (val) ((bitwise-and a val) . -> . a))
    (andb "B AND ~a -> B" (val) ((bitwise-and b val) . -> . b))
    (oraa "A OR ~a -> A"  (val) ((bitwise-ior a val) . -> . a))
    (orab "B OR ~a -> B"  (val) ((bitwise-ior b val) . -> . b))
    (eora "A XOR ~a -> A" (val) ((bitwise-xor a val) . -> . a))
    (eorb "B XOR ~a -> B" (val) ((bitwise-xor b val) . -> . b))

    (asl "~a shifted left" (addr) ((shift-left (ref addr)) . ~> . addr))
    (asla "A shifted left" () ((shift-left a) . -> . a))
    (aslb "B shifted left" () ((shift-left b) . -> . b))

    (asr "~a shifted right" (addr) ((arithmetic-shift-right (ref addr)) . ~> . addr) (sign #f))
    (asra "A shifted right" () ((arithmetic-shift-right a) . -> . a) (sign #f))
    (asrb "B shifted right" () ((arithmetic-shift-right b) . -> . b) (sign #f))

    (lsr "~a logically shifted right" (addr) ((logical-shift-right (ref addr)) . ~> . addr))
    (lsra "A logically shifted right" () ((logical-shift-right a) . -> . a))
    (lsrb "B logically shifted right" () ((logical-shift-right b) . -> . b))

    (dec "~a - 1" (addr) ((8bit- (ref addr) 1) . ~> . addr))
    (deca "A - 1 -> A" () ((8bit- a 1) . -> . a))
    (decb "B - 1 -> B" () ((8bit- b 1) . -> . b))
    (inc "~a + 1" (addr) ((8bit+ (ref addr) 1) . ~> . addr))
    (inca "A + 1" () ((8bit+ a 1) . -> . a))
    (incb "B + 1" () ((8bit+ b 1) . -> . b))
    (rol "Rotate ~a left through carry" () (void))
    (rola "Rotate A left through carry" () (void))
    (rolb "Rotate B left through carry" () (void))
    (ror "Rotate ~a right through carry" () (void))
    (rora "Rotate A right through carry" () (void))
    (rorb "Rotate B right through carry" () (void))
    (com "Complement ~a" () (void))
    (coma "Complement A" () (void))
    (comb "Complement B" () (void))
    (neg "Negate ~a" (addr) ((8bit- 0 (ref addr)) . ~> . addr))
    (nega "Negate A" () ((8bit- 0 a) . -> . a))
    (negb "Negate B" () ((8bit- 0 b) . -> . b))
    (daa "Decimal adjust A" () ((nib+nib
                                  (4bit+ (nib-high a)
                                         (if (or (>= (nib-high a) 10) (half?)) 6 0))
                                  (4bit+ (nib-low a)
                                         (if (or (>= (nib-low a) 10) (half?)) 6 0))) . -> . a))

    ;; status
    (bita "A AND ~a -> SR" (val) (void))
    (bitb "B AND ~a -> SR" (val) (void))
    (cba "A - B -> SR" () (void))
    (cmpa "A - ~a -> SR" (val) (void))
    (cmpb "B - ~a -> SR" (val) (void))
    (cpx "IX - ~a -> SR" (val) (void))
    (tst "~a - 0 -> SR" (val) (void))
    (tsta "A - 0 -> SR" () (void))
    (tstb "B - 0 -> SR" () (void))

    ;; clear
    (clr "Clear ~a" (addr) (0 . ~> . addr) (carry #f) (zero #t) (sign #f) (overflow #f))
    (clra "Clear A" () (0 . -> . a) (carry #f) (zero #t) (sign #f) (overflow #f))
    (clrb "Clear B" () (0 . -> . b) (carry #f) (zero #t) (sign #f) (overflow #f))
    (clc "Clear carry" () (carry #f))
    (cli "Clear interrupt" () (interrupt #f))
    (clv "Clear overflow" () (overflow #f))

    ;; set
    (sec "Set carry" () (carry #t))
    (sei "Set interrupt" () (interrupt #t))
    (sev "Set overflow" () (overflow #t))

    ;; noop
    (nop "Do nothing" () (void))
    (wai "Wait for interrupt" () (push! (low pc))
                                 (push! (high pc))
                                 (push! (low ix))
                                 (push! (high ix))
                                 (push! a)
                                 (push! b)
                                 (push! sr)
                                 (wait-for-interrupt))
    ))
